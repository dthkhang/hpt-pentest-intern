# Tìm hiểu về Cross-Site Scripting
> TÊN TÀI LIỆU: Cross-Site Scripting Document <br>
THỰC HIỆN: Dương Tôn Hoàng Khang <br>
CẬP NHẬT CUỐI CÙNG: 03/10/2024<br>
>
## Mục lục
#### [1. What is XSS (Cross-Site Scripting)?](#p1)<br>
#### [2. Các dạng lỗi XSS](#p2)<br>
#### [3. Cách thức tìm kiếm và khai thác](#p3)<br>
#### [4. Thực hành](#p4)<br>
#### [5. Cách khắc phục](#p5)<br>


<a id="p1"></a> <br>
## 1. What is XSS (Cross-Site Scripting)?<br>
Là lỗ hổng bảo mật phổ biến trong Web Application, cho phép Attacker chèn mã độc (thường là JavaScript) vào trang web mà user khác có thể truy cập. Lỗ hổng này có thể dẫn đến việc đánh cắp thông tin nhạy cảm (như cookie, token phiên), thao tác nội dung trang, hoặc thậm chí tấn công vào người dùng khác.<br>
<a id="p2"></a>
## 2. Các dạng lỗi XSS<br>
XSS có 3 dạng lỗi chính:<br>
- Stored XSS (XSS lưu trữ): Mã độc được lưu trữ trên server (thường là trong cơ sở dữ liệu) và được thực thi khi người dùng truy cập vào trang web chứa mã đó. <br>
    - VD: ta có 1 challenge về Basic Stored XSS của Vuln Lab như sau <br>
    <img src="img/xss-exam7.png" alt="alt text" width="600"> <br>
Màn hình sau khi login gồm các chức năng chính Xóa tất cả mess và submit mess <br>
    <img src="img/xss-exam8.png" alt="alt text" width="600"> <br>
Góc bên phải màn hình cho phép ta xem Soucre Code <br>
Đây là chức năng xóa mess và submit mess <br>
Nhìn qua thì thấy mess input được đẩy thẳng lên database mà không được filter validate data <br>
    <img src="img/xss-exam9.png" alt="alt text" width="600"> <br>
Còn đây là chức năng hiển thị nội dụng mess được lấy về từ data, và cũng không được thực hiện validate data <br>
    <img src="img/xss-exam10.png" alt="alt text" width="600"> <br>
Được biết, $cikti['content'] là nội dung mess, được nằm trong cặp tag div <br>
Để khai thác XSS, ta thực hiện injection với ý tưởng payload như sau: <br>
Trước tiên đóng tag div trước, chèn cặp tag script kèm script payload  vào, thực hiện mở div ra để tạo 1 cặp div hoàn chỉnh với code cho sẵn <br>
Ta có payload hoàn chỉnh như sau, chữ đen là input nhập vào mess submit <br>
    <img src="img/xss-exam11.png" alt="alt text" width="600"> <br>
Kết quả:
    <img src="img/xss-exam12.png" alt="alt text" width="600"> <br>
Kết quả sau khi login lại: <br>
    <img src="img/xss-exam13.png" alt="alt text" width="600"> <br>
Cách khác phục: <br>
Sử dụng hàm htmlspecialchars() để xử lý data đầu vào, Hàm này dùng để chuyển đổi các ký tự đặc biệt như <, >, ", ' thành các thực thể HTML an toàn. Thông số ENT_QUOTES đảm bảo rằng cả dấu nháy đơn và dấu nháy kép đều được thoát, còn 'UTF-8' chỉ định bộ mã ký tự. <br>
    <img src="img/xss-exam14.png" alt="alt text" width="600"> <br>

- Reflected XSS (XSS phản hồi): Mã độc được chèn trực tiếp vào URL hoặc form và được thực thi khi trang web phản hồi lại người dùng mà không kiểm tra mã độc.<br>
    - VD: ta có 1 challenge về Basic Reflected của Vuln Lab như sau <br>
<img src="img/xss-exam1.png" alt="alt text" width="600"> <br>
Test thử chức năng search như 1 normal user <br>
<img src="img/xss-exam2.png" alt="alt text" width="600"> <br>
Góc phải của Challenge cho mình xem Source Code, giờ xem thử nha <br>
<img src="img/xss-exam3.png" alt="alt text" width="600"> <br>
Tại vị trí được đóng khung đỏ, ta có thể thấy biến $q = $_GET['q'] có nhiệm vụ lấy data từ search input và reflect nó lại mà không hề có bất cứ 1 filter nào thực hiện validate input được lấy từ search input ra. <br>
Từ đó ta có thể xác định search input này có thể đang bị Reflected XSS<br>
Được biết $q được nằm trong cặp tag b, và để khai thác XSS thì ta thực hiện injection vào search input <br>
Ta có đoạn reflect code đã cho như sau: <br>
echo '' . $strings['text'] . ' <b>' . $q . '</b> '; <br>
<img src="img/xss-exam4.png" alt="alt text" width="600"> <br>
Kết quả: <br>
<img src="img/xss-exam5.png" alt="alt text" width="600"> <br>
Cách khắc phục: <br>
Sử dụng hàm htmlspecialchars() để xử lý data đầu vào, Hàm này dùng để chuyển đổi các ký tự đặc biệt như <, >, ", ' thành các thực thể HTML an toàn. Thông số ENT_QUOTES đảm bảo rằng cả dấu nháy đơn và dấu nháy kép đều được thoát, còn 'UTF-8' chỉ định bộ mã ký tự.
<img src="img/xss-exam6.png" alt="alt text" width="600"> <br>

- DOM-based XSS: XSS xảy ra khi mã độc được thực thi trực tiếp trong trình duyệt của người dùng, thông qua việc thao tác DOM (Document Object Model) của trang.<br>
    - VD: ta có 1 challenge về Basic DOM XSS của Vuln Lab với chức năng tính diện tích hình tam giác như sau: <br>
<img src="img/xss-exam15.png" alt="alt text" width="600"> <br>
Vẫn là góc phải màn hình cho phép ta xem Source code <br>
<img src="img/xss-exam16.png" alt="alt text" width="600"> <br>
Ta có thể thấy, code trên lấy trực tiếp 2 tham số base, height từ user và đưa vào mã JavaScript mà không vallidate data, điều này có thể dẫn đến việc user nhập các kí tự đặt biệt hoặc injection mã độc vào <br>
Để khai thác, ta thực hiện như sau: <br>
F12 lên ta có thể thấy được javascript với phép tính height 12, base 12 <br>
<img src="img/xss-exam17.png" alt="alt text" width="600"> <br>
Thực hiện injection với payload như sau: <br>
<img src="img/xss-exam18.png" alt="alt text" width="600"> <br>
Kết quả: <br>
<img src="img/xss-exam19.png" alt="alt text" width="600"> <br>
Cách khắc phục: <br>
Sử dụng hàm json_encode() đảm bảo rằng các giá trị từ $_GET['base'] và $_GET['height'] được thoát đúng cách khi được sử dụng trong JavaScript, ngăn chặn việc chèn mã độc. <br>
JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_HEX_QUOT: Các tùy chọn này đảm bảo rằng các ký tự đặc biệt như <, >, &, ', và " được mã hóa thành các thực thể an toàn cho JavaScript. <br>
Kiểm tra kỹ giá trị của base và height để đảm bảo chúng là số hợp lệ, sử dụng is_numeric() trước khi sử dụng giá trị đó. <br>
<img src="img/xss-exam20.png" alt="alt text" width="600"> <br>


<a id="p3"></a>
## 3. Cách thức tìm kiếm và khai thác<br>
Để tìm kiếm và khai thác lỗ hổng XSS (Cross-Site Scripting), bạn có thể thực hiện theo các bước sau:<br>
- Kiểm tra input đầu vào của user<br>
    - XSS thường xuất hiện khi dữ liệu từ user không được filter đúng cách trước khi được hiển thị lại trên trang web. Cần xác định tất cả các điểm mà trang web chấp nhận đầu vào từ người dùng, chẳng hạn như:<br>
        - Login form, chức năng search<br>
        - Chức năng comment<br>
        - URL (query parameters)<br>
        - Cookies, headers<br>
        
Sau khi xác định chức năng bị XSS, ta có thể khai thác sâu hơn, ví dụ như: <br>
-  Đánh cắp cookie của người dùng<br>
- Thực thi mã JavaScript độc hạ<br>
- Chèn keylogger<br>
- Redirect user đến trang giả mạo để Phishing Attack.<br>
<a id="p4"></a> <br>
## 4. Thực hành<br>
- Challenge 1:<br>
Ta có 1 trang web như sau:<br>
<img src="img/chall-xss-exam.png" alt="alt text" width="600"> <br>
Trước khi bắt đầu tìm Flag thì mình thực hiện Information Gathering để tìm hiểu work flow của challenge này trước, test thử qua hết tất cả chức năng hiện có của Challenge.<br>
Đồng thời phải bật Burp Suite lên, add url challenge vào scope để follow các HTTP Request được gửi đi đã.<br>
    <img src="img/chall-xss15-exam.png" alt="alt text" width="600"> <br>
    - Register<br>
    <img src="img/chall-xss1-exam.png" alt="alt text" width="600"> <br>
    Request sau khi Resgister thành công, status code 302 chuyển về /login <br>
    <img src="img/chall-xss16-exam.png" alt="alt text" width="600"> <br>
    - Login: <br>
    <img src="img/chall-xss2-exam.png" alt="alt text" width="600"> <br>
    Request sau khi Login thành công, status code chuyền về /profile <br>
    <img src="img/chall-xss17-exam.png" alt="alt text" width="600"> <br>
Sau khi Login thành công thì đây là giao diện chính<br>
Tại đây có thông tin user, các chức năng như Home, Blogs, Feedback, Update Profile,... <br>
    <img src="img/chall-xss3-exam.png" alt="alt text" width="600"> <br>
Lướt qua các chức năng Home, Blogs thì không có gì đặt biệt hoặc chưa có gì đặt biệt. <br>
    <img src="img/chall-xss4-exam.png" alt="alt text" width="600"> <br>
    <img src="img/chall-xss5-exam.png" alt="alt text" width="600"> <br>
    <img src="img/chall-xss6-exam.png" alt="alt text" width="600"> <br>
Quay trở lại, ở chức năng Feedback ta có thể gửi message và nội dung messagae được Reflected lại tại mục Your Feedback và cứ mỗi 3 phút thì admin sẽ check feedback.<br>
=> Chức năng này có thể bị Reflected XSS hoặc Stored XSS (vì data feedback có thể được lưu trên server)<br>
<img src="img/chall-xss7-exam.png" alt="alt text" width="600"> <br>
Test vài test payload cơ bản của XSS<br>
<img src="img/chall-xss8-exam.png" alt="alt text" width="600"> <br>
Payload này không thực hiện được, và Your Feedback print cả nội dung payload ra ngoài, F12 lên thì check thấy payload đã bị encode<br>
<img src="img/chall-xss9-exam.png" alt="alt text" width="600"> <br>
Nhưng sau 3 phút thì cloumn Admin read thay đổi trạng thái từ unred sang read, vậy có thể phía user client không bị XSS, nhưng phía admin vẫn có thể bị XSS, type này là Blind-XSS <br>
Test 1 payload khác cùng webhook, ý tượng là dùng js tạo ra 1 img với src=webhook, để khi admin vào xem feedback, brower của admin sẽ thực hiện 1 request đến src=webhook để get ảnh <br>
Submit payload và đợi status admin read chuyển sang read, check webhook xem có phản hồi không. <br>
<img src="img/chall-xss10-exam.png" alt="alt text" width="600"> <br>
May quá, đúng như dự đoán, vậy là phía admin dính XSS theo type Blind-XSS <br>
<img src="img/chall-xss11-exam.png" alt="alt text" width="600"> <br>
Dến đây vẫn chưa ra Flag, impact level lên xíu :> cũng ý tưởng cũ, nhưng  thêm ?cookie=document.cookie với mục đích lấy cookie của admin. <br>
Sau 3 phút, khi admni vô đọc feedback thì webhook hứng trọn cookie của admin luôn <br>
<img src="img/chall-xss12-exam.png" alt="alt text" width="600"> <br>
Giờ thì lấy cookie admin và đăng nhập thôi<br>
Bật Burp Suite, vào Proxy -> HTTP History, chuyển request /profile sang tab Repeater, sửa cookie của user test thành admin và send<br>
<img src="img/chall-xss14-exam.png" alt="alt text" width="600"> <br>
Lụm FLAG ~~
<a id="p5"></a> <br>
## 5. Một số cách khắc khục phổ biến
- Kiểm tra và lọc dữ liệu đầu vào (Input Validation) <br>
Tất cả các dữ liệu từ người dùng nhập vào (như form, URL, query parameters) cần được kiểm tra và lọc trước khi xử lý. Không bao giờ tin tưởng đầu vào từ phía người dùng.<br>
Nếu có thể, hãy giới hạn dữ liệu đầu vào theo kiểu dữ liệu mong muốn (ví dụ: chỉ chấp nhận số, chữ cái, hoặc ký tự đặc biệt).<br>
<br>
- Thoát ký tự (Escaping) <br>
Khi dữ liệu đầu vào của người dùng cần được hiển thị trên trang web, cần phải thoát các ký tự đặc biệt có thể gây nguy hiểm trong HTML, JavaScript, hoặc URL.<br>
<img src="img/xss11-exam.png" alt="alt text" width="600"> <br>
<br>
- Sử dụng hàm thoát ký tự (Sanitization)
    - Sử dụng các thư viện hoặc framework có sẵn để tự động lọc và thoát dữ liệu trước khi nó được sử dụng trong HTML hoặc JavaScript. Ví dụ:<br>
        - PHP: htmlspecialchars() <br>
        - Python (Django): Tính năng auto-escaping của Django<br>
        - avaScript (Node.js): Thư viện như xss-filters hoặc DOMPurify<br>
<br>
- Áp dụng Content Security Policy (CSP) <br>
    - CSP là một cơ chế bảo mật cho phép kiểm soát các nguồn mà trình duyệt có thể tải và thực thi tài nguyên (như JavaScript, CSS, hình ảnh, v.v.). CSP giúp giảm thiểu rủi ro XSS bằng cách ngăn cản việc tải các mã JavaScript không mong muốn từ các nguồn không đáng tin cậy.<br>
    - Ví dụ về CSP trong HTTP header:<br>
        > Content-Security-Policy: default-src 'self'; script-src 'self' 'https://trustedsource.com'; <br>
    - Lợi ích của CSP: Ngăn chặn các mã JavaScript lạ hoặc độc hại chạy trên trình duyệt nếu bị chèn vào trang.<br>
<br>
- Sử dụng HttpOnly Flag cho Cookie <br>
    - Cookie có thể chứa thông tin nhạy cảm như session token hoặc thông tin đăng nhập. Thiết lập cờ HttpOnly cho cookie sẽ ngăn không cho JavaScript truy cập vào cookie, từ đó bảo vệ khỏi các cuộc tấn công XSS nhằm đánh cắp cookie.<br>
    - VD:<br>
        > Set-Cookie: sessionID=abc123; HttpOnly<br>
<br>
- Sử dụng SameSite Flag cho Cookie <br>
    - Thuộc tính SameSite giúp ngăn chặn việc gửi cookie trong các yêu cầu đến từ bên ngoài, từ đó giảm thiểu khả năng cookie bị đánh cắp thông qua tấn công CSRF (Cross-Site Request Forgery) hoặc XSS.<br>
    - VD: <br>
        > Set-Cookie: sessionID=abc123; SameSite=Strict<br>





